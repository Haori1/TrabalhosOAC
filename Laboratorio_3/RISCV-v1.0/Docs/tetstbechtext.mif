DEPTH = 4096;
WIDTH = 32;
ADDRESS_RADIX = HEX;
DATA_RADIX = HEX;
CONTENT
BEGIN
00000000 : 0fc10317;   % 11: 	la t1, N	#t1 = 5 %
00000001 : 00030313;   % 11:  %
00000002 : 00032283;   % 12: 	lw t0, 0(t1) %
00000003 : 04532023;   % 13: 	sw t0, 64(t1) %
00000004 : 04032283;   % 14: 	lw t0, 64(t1) %
00000005 : 00029463;   % 15: 	bne t0, zero, PULAERRO1 %
00000006 : 328002ef;   % 17: 	jal t0, ERRO %
00000007 : 00a00313;   % 19: 	li t1, 10 %
00000008 : 005282b3;   % 20: 	add t0, t0, t0	#t0 = 5 + 5 %
00000009 : 00628463;   % 22: 	beq t0, t1, PULAERRO2 %
0000000a : 318002ef;   % 23: 	jal t0, ERRO %
0000000b : 405282b3;   % 26: 	sub t0, t0, t0 #t0 = 0 %
0000000c : 00028463;   % 28: 	beq t0, zero, PULAERRO3 %
0000000d : 30c002ef;   % 29: 	jal t0, ERRO %
0000000e : 00500293;   % 32: 	li t0, 5 %
0000000f : 0002f2b3;   % 33: 	and t0, t0, zero #and t0, 0 = 0 %
00000010 : 00028463;   % 35: 	beq t0, zero, PULAERRO4 %
00000011 : 2fc002ef;   % 36: 	jal t0, ERRO %
00000012 : 00100293;   % 39: 	li t0, 1 %
00000013 : 00000313;   % 40: 	li t1, 0 %
00000014 : 00100393;   % 41: 	li t2, 1 %
00000015 : 0062e2b3;   % 43: 	or t0, t0, t1 #or, t0, t1 = 1 %
00000016 : 00728463;   % 44: 	beq t0, t2, PULAERRO5 %
00000017 : 2e4002ef;   % 45: 	jal t0, ERRO %
00000018 : 00100293;   % 48: 	li t0, 1 %
00000019 : 00100313;   % 49: 	li t1, 1 %
0000001a : 00000393;   % 50: 	li t2, 0 %
0000001b : 0062c2b3;   % 52: 	xor t0, t0, t1 #xor, t0, t1 = 0 %
0000001c : 00728463;   % 53: 	beq t0, t2, PULAERRO6 %
0000001d : 2cc002ef;   % 54: 	jal t0, ERRO %
0000001e : 00500293;   % 57: 	li t0, 5 %
0000001f : 00300313;   % 58: 	li t1, 3 %
00000020 : 0062a2b3;   % 60: 	slt t0, t0, t1 #t0 < t1 = 0 %
00000021 : 00028463;   % 61: 	beq t0, zero, PULAERRO7 %
00000022 : 2b8002ef;   % 62: 	jal t0, ERRO %
00000023 : 00500293;   % 65: 	li t0, 5 %
00000024 : 00300313;   % 66: 	li t1, 3 %
00000025 : 00100393;   % 67: 	li t2, 1 %
00000026 : 005332b3;   % 69: 	sltu t0, t1, t0 #t1 < t0 = 1 %
00000027 : 00728463;   % 70: 	beq t0, t2, PULAERRO8 %
00000028 : 2a0002ef;   % 71: 	jal t0, ERRO %
00000029 : 00400293;   % 74: 	li t0, 4 %
0000002a : 00100313;   % 75: 	li t1, 1 %
0000002b : 00800393;   % 76: 	li t2, 8 %
0000002c : 006292b3;   % 78: 	sll t0, t0, t1 #t0 = t0 << t1 %
0000002d : 00728263;   % 79: 	beq t0, t2, PULAERRO9 #t0 = 8 %
0000002e : 00400293;   % 82: 	li t0, 4 %
0000002f : 00100313;   % 83: 	li t1, 1 %
00000030 : 00200393;   % 84: 	li t2, 2 %
00000031 : 0062d2b3;   % 86: 	srl t0, t0, t1 %
00000032 : 00728463;   % 87: 	beq t0, t2, PULAERRO10 %
00000033 : 274002ef;   % 88: 	jal t0, ERRO %
00000034 : 00400293;   % 91: 	li t0, 4 %
00000035 : 00100313;   % 92: 	li t1, 1 %
00000036 : 00200393;   % 93: 	li t2, 2 %
00000037 : 4062d2b3;   % 95: 	sra t0, t0, t1 %
00000038 : 00728463;   % 96: 	beq t0, t2, PULAERRO11 %
00000039 : 25c002ef;   % 97: 	jal t0, ERRO %
0000003a : 00500293;   % 100: 	li t0, 5 %
0000003b : 00a00393;   % 101: 	li t2, 10 %
0000003c : 00528293;   % 102: 	addi t0, t0, 5 %
0000003d : 00728463;   % 103: 	beq t0, t2, PULAERRO12 %
0000003e : 248002ef;   % 104: 	jal t0, ERRO %
0000003f : 00107293;   % 107: 	andi t0, zero, 1 %
00000040 : 00028463;   % 108: 	beq t0, zero, PULAERRO13 %
00000041 : 23c002ef;   % 109: 	jal t0, ERRO %
00000042 : 00100293;   % 112: 	li t0, 1 %
00000043 : 00100393;   % 113: 	li t2, 1 %
00000044 : 0002c293;   % 114: 	xori t0, t0, 0 %
00000045 : 00728463;   % 115: 	beq t0, t2, PULAERRO14 %
00000046 : 228002ef;   % 116: 	jal t0, ERRO %
00000047 : 00200293;   % 119: 	li t0, 2 %
00000048 : 0012a293;   % 120: 	slti t0, t0, 1 #t0 = t0 < 1 %
00000049 : 00028463;   % 121: 	beq t0, zero, PULAERRO15 %
0000004a : 218002ef;   % 122: 	jal t0, ERRO %
0000004b : 00200293;   % 125: 	li t0, 2 %
0000004c : 0012b293;   % 126: 	sltiu t0, t0, 1 %
0000004d : 00028463;   % 127: 	beq t0, zero, PULAERRO16 %
0000004e : 208002ef;   % 128: 	jal t0, ERRO %
0000004f : 00200293;   % 131: 	li t0, 2 %
00000050 : 00400313;   % 132: 	li t1, 4 %
00000051 : 00129293;   % 133: 	slli t0, t0, 1 %
00000052 : 00628463;   % 134: 	beq t0, t1, PULAERRO17 %
00000053 : 1f4002ef;   % 135: 	jal t0, ERRO %
00000054 : 00200293;   % 138: 	li t0, 2 %
00000055 : 00100393;   % 139:   	li t2, 1 %
00000056 : 4012d293;   % 140:   	srai t0, t0, 1 %
00000057 : 00728463;   % 141:   	beq t0, t2, PULAERRO18 %
00000058 : 1e0002ef;   % 142:   	jal t0, ERRO %
00000059 : 00000297;   % 145: 	auipc t0, 0 #PC %
0000005a : 00000317;   % 146:   	auipc t1, 0 #PC + 4 %
0000005b : 00400393;   % 147:   	li t2, 4 %
0000005c : 40730333;   % 148:   	sub t1, t1, t2 #t1 = t1 - 4 %
0000005d : 00628463;   % 149:   	beq t0, t1, PULAERRO19 %
0000005e : 1c8002ef;   % 150:   	jal t0, ERRO %
0000005f : 00000293;   % 153: 	li t0, 0 %
00000060 : 000012b7;   % 154: 	lui t0, 1 #t0 = 4096 %
00000061 : 00001337;   % 155: 	li t1, 4096 %
00000062 : 00030313;   % 155:  %
00000063 : 00628463;   % 156: 	beq t0, t1, PULAERRO20 %
00000064 : 1b0002ef;   % 157: 	jal t0, ERRO %
00000065 : 00000293;   % 160: 	li t0, 0 %
00000066 : 00500463;   % 161: 	beq zero, t0, PULAERRO21 %
00000067 : 1a4002ef;   % 162: 	jal t0, ERRO %
00000068 : 00500293;   % 165: 	li t0, 5 %
00000069 : 00501463;   % 166: 	bne zero, t0, PULAERRO24 %
0000006a : 198002ef;   % 167: 	jal t0, ERRO %
0000006b : 00500293;   % 182: 	li t0, 5 %
0000006c : 00200313;   % 183: 	li t1, 2 %
0000006d : 00534463;   % 184: 	blt t1, t0, PULAERRO26 %
0000006e : 188002ef;   % 185: 	jal t0, ERRO %
0000006f : 00000397;   % 194: 	la t2, ERRO %
00000070 : 18438393;   % 194:  %
00000071 : 008000ef;   % 195: 	jal PULAERRO27 %
00000072 : 000382e7;   % 196: 	jalr t0, t2, 0 %
00000073 : 00000397;   % 199: 	la t2, PULAERRO28 %
00000074 : 01038393;   % 199:  %
00000075 : 000382e7;   % 200: 	jalr t0, t2, 0 %
00000076 : 168002ef;   % 201: 	jal t0, ERRO %
00000077 : 0fc10317;   % 204: 	la t1, NB %
00000078 : e2e30313;   % 204:  %
00000079 : 00030283;   % 205: 	lb t0, 0(t1) %
0000007a : 04530223;   % 206: 	sb t0, 68(t1) %
0000007b : 04430283;   % 207: 	lb t0, 68(t1) %
0000007c : 00029463;   % 208: 	bne t0, zero, PULAERRO29 %
0000007d : 14c002ef;   % 209: 	jal t0, ERRO %
0000007e : 0fc10317;   % 212: 	la t1, NB %
0000007f : e1230313;   % 212:  %
00000080 : 00034283;   % 213: 	lbu t0, 0(t1) %
00000081 : 04530423;   % 214: 	sb t0, 72(t1) %
00000082 : 04834283;   % 215: 	lbu t0, 72(t1) %
00000083 : 00029463;   % 216: 	bne t0, zero, PULAERRO30 %
00000084 : 130002ef;   % 217: 	jal t0, ERRO %
00000085 : 0fc10317;   % 220: 	la t1, NH %
00000086 : df430313;   % 220:  %
00000087 : 00031283;   % 221: 	lh t0, 0(t1) %
00000088 : 04531623;   % 222: 	sh t0, 76(t1) %
00000089 : 04c31283;   % 223: 	lh t0, 76(t1) %
0000008a : 00029463;   % 224: 	bne t0, zero, PULAERRO31 %
0000008b : 114002ef;   % 225: 	jal t0, ERRO %
0000008c : 0fc10317;   % 228: 	la t1, NH %
0000008d : dd830313;   % 228:  %
0000008e : 00035283;   % 229: 	lhu t0, 0(t1) %
0000008f : 04531623;   % 230: 	sh t0, 76(t1) %
00000090 : 04c35283;   % 231: 	lhu t0, 76(t1) %
00000091 : 00029463;   % 232: 	bne t0, zero, MUL %
00000092 : 0f8002ef;   % 233: 	jal t0, ERRO %
00000093 : 0fc10317;   % 236: 	la t1, R32VIM %
00000094 : de030313;   % 236:  %
00000095 : 00032283;   % 237: 	lw t0, 0(t1) %
00000096 : 00029463;   % 238: 	bne t0, zero, PULAERRO32 #Se R32VIM for 1 a multiplicacao eh testada %
00000097 : 130002ef;   % 239: 	jal t0, END %
00000098 : 00500293;   % 243: 	li t0, 5 %
00000099 : 00300313;   % 244: 	li t1, 3 %
0000009a : 00f00393;   % 245: 	li t2, 15 %
0000009b : 026282b3;   % 246: 	mul t0, t0, t1 %
0000009c : 00728463;   % 247: 	beq t0, t2, PULAERRO33 %
0000009d : 0cc002ef;   % 248: 	jal t0, ERRO %
0000009e : 00200293;   % 251: 	li t0, 0x00000002 %
0000009f : 00900313;   % 252: 	li t1, 0x00000009 %
000000a0 : 026292b3;   % 253: 	mulh t0, t0, t1 %
000000a1 : 00028463;   % 254: 	beq t0, zero, PULAERRO34 %
000000a2 : 0b8002ef;   % 255: 	jal t0, ERRO %
000000a3 : 00200293;   % 258: 	li t0, 0x00000002 %
000000a4 : 00900313;   % 259: 	li t1, 0x00000009 %
000000a5 : 0262b2b3;   % 260: 	mulhu t0, t0, t1 %
000000a6 : 00028463;   % 261: 	beq t0, zero, PULAERRO35 %
000000a7 : 0a4002ef;   % 262: 	jal t0, ERRO %
000000a8 : 00200293;   % 265: 	li t0, 0x00000002 %
000000a9 : 00900313;   % 266: 	li t1, 0x00000009 %
000000aa : 0262a2b3;   % 267: 	mulhsu t0, t0, t1 %
000000ab : 00028463;   % 268: 	beq t0, zero, PULAERRO36 %
000000ac : 090002ef;   % 269: 	jal t0, ERRO %
000000ad : 00400293;   % 272: 	li t0, 4 %
000000ae : 00200313;   % 273: 	li t1, 2 %
000000af : 0262c2b3;   % 274: 	div t0, t0, t1 %
000000b0 : 00628463;   % 275: 	beq t0, t1, PULAERRO37 %
000000b1 : 07c002ef;   % 276: 	jal t0, ERRO %
000000b2 : 00400293;   % 279: 	li t0, 4 %
000000b3 : 00200313;   % 280: 	li t1, 2 %
000000b4 : 0262d2b3;   % 281: 	divu t0, t0, t1 %
000000b5 : 00628463;   % 282: 	beq t0, t1, PULAERRO38 %
000000b6 : 068002ef;   % 283: 	jal t0, ERRO %
000000b7 : 00500293;   % 286: 	li t0, 5 %
000000b8 : 00300313;   % 287: 	li t1, 3 %
000000b9 : 00200393;   % 288: 	li t2, 2 %
000000ba : 0262e2b3;   % 289: 	rem t0, t0, t1 %
000000bb : 00728463;   % 290: 	beq t0, t2, PULAERRO39 %
000000bc : 050002ef;   % 291: 	jal t0, ERRO %
000000bd : 00500293;   % 294: 	li t0, 5 %
000000be : 00300313;   % 295: 	li t1, 3 %
000000bf : 00200393;   % 296: 	li t2, 2 %
000000c0 : 0262f2b3;   % 297: 	remu t0, t0, t1 %
000000c1 : 00728463;   % 298: 	beq t0, t2, SUCESSO %
000000c2 : 038002ef;   % 299: 	jal t0, ERRO %
000000c3 : 00700513;   % 303: 	li a0, 0x07 %
000000c4 : 09400893;   % 304: 	li a7, 148 %
000000c5 : 080000ef;   % 305: 	jal exceptionHandling %
000000c6 : 06800893;   % 308: 	li a7, 104 %
000000c7 : 0fc10517;   % 309: 	la a0, MSG2 %
000000c8 : d0350513;   % 309:  %
000000c9 : 00000593;   % 310: 	li a1, 0 %
000000ca : 00000613;   % 311: 	li a2, 0 %
000000cb : 000106b7;   % 312: 	li a3, 0xFF00 %
000000cc : f0068693;   % 312:  %
000000cd : 060000ef;   % 313: 	jal exceptionHandling %
000000ce : 00a00893;   % 316: 	addi a7, zero, 10 %
000000cf : 058000ef;   % 317: 	jal exceptionHandling %
000000d0 : 00700513;   % 320: 	li a0, 0x07 %
000000d1 : 09400893;   % 321: 	li a7, 148 %
000000d2 : 04c000ef;   % 322: 	jal exceptionHandling %
000000d3 : 06800893;   % 325: 	li a7, 104 %
000000d4 : 0fc10517;   % 326: 	la a0, MSG %
000000d5 : cbb50513;   % 326:  %
000000d6 : 00000593;   % 327: 	li a1, 0 %
000000d7 : 00000613;   % 328: 	li a2, 0 %
000000d8 : 000106b7;   % 329: 	li a3, 0xFF00 %
000000d9 : f0068693;   % 329:  %
000000da : 02c000ef;   % 330: 	jal exceptionHandling %
000000db : ff828293;   % 333: 	addi t0, t0, -8 #Endereco onde ocorreu o erro %
000000dc : 00500533;   % 334: 	mv a0, t0 %
000000dd : 08600893;   % 335: 	li a7, 134 %
000000de : 09400593;   % 336: 	li a1, 148 %
000000df : 00000613;   % 337: 	li a2, 0 %
000000e0 : 000106b7;   % 338: 	li a3, 0xFF00 %
000000e1 : f0068693;   % 338:  %
000000e2 : 00c000ef;   % 339: 	jal exceptionHandling %
000000e3 : 00a00893;   % 343: 	addi a7, zero, 10 %
000000e4 : 004000ef;   % 344: 	jal exceptionHandling %
000000e5 : ffc10113;   % 166: exceptionHandling:  addi    sp, sp, -4 # aloca espaco  %
000000e6 : 00112023;   % 167:     sw      ra, 0(sp)			# salva ra %
000000e7 : 0100006f;   % 169:    	j ecallException %
000000e8 : 00012083;   % 171: endException: 	lw   ra, 0(sp)		# recupera ra %
000000e9 : 00410113;   % 172:     	addi    sp, sp, 4 %
000000ea : 00008067;   % 180: 		jalr zero, ra, 0			# retorna PC=uepc %
000000eb : ef810113;   % 186: ecallException:     addi    sp, sp, -264              # Salva todos os registradores na pilha %
000000ec : 00112023;   % 187:     sw      x1,    0(sp) %
000000ed : 00212223;   % 188:     sw      x2,    4(sp) %
000000ee : 00312423;   % 189:     sw      x3,    8(sp) %
000000ef : 00412623;   % 190:     sw      x4,   12(sp) %
000000f0 : 00512823;   % 191:     sw      x5,   16(sp) %
000000f1 : 00612a23;   % 192:     sw      x6,   20(sp) %
000000f2 : 00712c23;   % 193:     sw      x7,   24(sp) %
000000f3 : 00812e23;   % 194:     sw      x8,   28(sp) %
000000f4 : 02912023;   % 195:     sw      x9,   32(sp) %
000000f5 : 02a12223;   % 196:     sw      x10,  36(sp) %
000000f6 : 02b12423;   % 197:     sw      x11,  40(sp) %
000000f7 : 02c12623;   % 198:     sw      x12,  44(sp) %
000000f8 : 02d12823;   % 199:     sw      x13,  48(sp) %
000000f9 : 02e12a23;   % 200:     sw      x14,  52(sp) %
000000fa : 02f12c23;   % 201:     sw      x15,  56(sp) %
000000fb : 03012e23;   % 202:     sw      x16,  60(sp) %
000000fc : 05112023;   % 203:     sw      x17,  64(sp) %
000000fd : 05212223;   % 204:     sw      x18,  68(sp) %
000000fe : 05312423;   % 205:     sw      x19,  72(sp) %
000000ff : 05412623;   % 206:     sw      x20,  76(sp) %
00000100 : 05512823;   % 207:     sw      x21,  80(sp) %
00000101 : 05612a23;   % 208:     sw      x22,  84(sp) %
00000102 : 05712c23;   % 209:     sw      x23,  88(sp) %
00000103 : 05812e23;   % 210:     sw      x24,  92(sp) %
00000104 : 07912023;   % 211:     sw      x25,  96(sp) %
00000105 : 07a12223;   % 212:     sw      x26, 100(sp) %
00000106 : 07b12423;   % 213:     sw      x27, 104(sp) %
00000107 : 07c12623;   % 214:     sw      x28, 108(sp) %
00000108 : 07d12823;   % 215:     sw      x29, 112(sp) %
00000109 : 07e12a23;   % 216:     sw      x30, 116(sp) %
0000010a : 07f12c23;   % 217:     sw      x31, 120(sp) %
0000010b : 000002b3;   % 252:     add     t0, zero, zero %
0000010c : 00000333;   % 253:     add     t1, zero, zero %
0000010d : 000003b3;   % 254:     add     t2, zero, zero %
0000010e : 00000e33;   % 255:     add     t3, zero, zero %
0000010f : 00000eb3;   % 256:     add     t4, zero, zero %
00000110 : 00000f33;   % 257:     add     t5, zero, zero %
00000111 : 00000fb3;   % 258:     add     t6, zero, zero %
00000112 : 00a00293;   % 261:     addi    t0, zero, 10 %
00000113 : 17128c63;   % 262:     beq     t0, a7, goToExit          # ecall exit %
00000114 : 06e00293;   % 263:     addi    t0, zero, 110 %
00000115 : 17128863;   % 264:     beq     t0, a7, goToExit          # ecall exit %
00000116 : 00100293;   % 266:     addi    t0, zero, 1               # ecall 1 = print int %
00000117 : 19128663;   % 267:     beq     t0, a7, goToPrintInt %
00000118 : 06500293;   % 268:     addi    t0, zero, 101             # ecall 1 = print int %
00000119 : 19128263;   % 269:     beq     t0, a7, goToPrintInt %
0000011a : 00200293;   % 271:     addi    t0, zero, 2               # ecall 2 = print float %
0000011b : 19128a63;   % 272:     beq     t0, a7, goToPrintFloat %
0000011c : 06600293;   % 273:     addi    t0, zero, 102             # ecall 2 = print float %
0000011d : 19128663;   % 274:     beq     t0, a7, goToPrintFloat %
0000011e : 00400293;   % 276:     addi    t0, zero, 4               # ecall 4 = print string %
0000011f : 17128a63;   % 277:     beq     t0, a7, goToPrintString %
00000120 : 06800293;   % 278:     addi    t0, zero, 104             # ecall 4 = print string %
00000121 : 17128663;   % 279:     beq     t0, a7, goToPrintString %
00000122 : 00500293;   % 281:     addi    t0, zero, 5               # ecall 5 = read int %
00000123 : 19128263;   % 282:     beq     t0, a7, goToReadInt %
00000124 : 06900293;   % 283:     addi    t0, zero, 105             # ecall 5 = read int %
00000125 : 17128e63;   % 284:     beq     t0, a7, goToReadInt %
00000126 : 00600293;   % 286:     addi    t0, zero, 6               # ecall 6 = read float %
00000127 : 19128263;   % 287:     beq     t0, a7, goToReadFloat %
00000128 : 06a00293;   % 288:     addi    t0, zero, 106             # ecall 6 = read float %
00000129 : 17128e63;   % 289:     beq     t0, a7, goToReadFloat %
0000012a : 00800293;   % 291:     addi    t0, zero, 8               # ecall 8 = read string %
0000012b : 17128663;   % 292:     beq     t0, a7, goToReadString %
0000012c : 06c00293;   % 293:     addi    t0, zero, 108             # ecall 8 = read string %
0000012d : 17128263;   % 294:     beq     t0, a7, goToReadString %
0000012e : 00b00293;   % 296:     addi    t0, zero, 11              # ecall 11 = print char %
0000012f : 13128e63;   % 297:     beq     t0, a7, goToPrintChar %
00000130 : 06f00293;   % 298:     addi    t0, zero, 111             # ecall 11 = print char %
00000131 : 13128a63;   % 299:     beq     t0, a7, goToPrintChar %
00000132 : 00c00293;   % 301:     addi    t0, zero, 12              # ecall 12 = read char %
00000133 : 13128e63;   % 302:     beq     t0, a7, goToReadChar %
00000134 : 07000293;   % 303:     addi    t0, zero, 112             # ecall 12 = read char %
00000135 : 13128a63;   % 304:     beq     t0, a7, goToReadChar %
00000136 : 01e00293;   % 306:     addi    t0, zero, 30              # ecall 30 = time %
00000137 : 17128263;   % 307:     beq     t0, a7, goToTime %
00000138 : 08200293;   % 308:     addi    t0, zero, 130             # ecall 30 = time %
00000139 : 15128e63;   % 309:     beq     t0, a7, goToTime %
0000013a : 02000293;   % 311:     addi    t0, zero, 32              # ecall 32 = sleep %
0000013b : 15128e63;   % 312:     beq     t0, a7, goToSleep %
0000013c : 08400293;   % 313:     addi    t0, zero, 132             # ecall 32 = sleep %
0000013d : 15128a63;   % 314:     beq     t0, a7, goToSleep %
0000013e : 02900293;   % 316:     addi    t0, zero, 41              # ecall 41 = random %
0000013f : 15128a63;   % 317:     beq     t0, a7, goToRandom %
00000140 : 08d00293;   % 318:     addi    t0, zero, 141             # ecall 41 = random %
00000141 : 15128663;   % 319:     beq     t0, a7, goToRandom %
00000142 : 02200293;   % 321:     addi    t0, zero, 34       	# ecall 34 = print hex %
00000143 : 11128e63;   % 322:     beq     t0, a7, goToPrintHex %
00000144 : 08600293;   % 323:     addi    t0, zero, 134		# ecall 41 = print hex %
00000145 : 11128a63;   % 324:     beq     t0, a7, goToPrintHex %
00000146 : 01f00293;   % 326:     addi    t0, zero, 31              # ecall 31 = MIDI out %
00000147 : 11128a63;   % 327:     beq     t0, a7, goToMidiOut       # Generate tone and return immediately %
00000148 : 08300293;   % 328:     addi    t0, zero, 131             # ecall 31 = MIDI out %
00000149 : 11128663;   % 329:     beq     t0, a7, goToMidiOut %
0000014a : 02100293;   % 331:     addi    t0, zero, 33              # ecall 33 = MIDI out synchronous %
0000014b : 11128663;   % 332:     beq     t0, a7, goToMidiOutSync   # Generate tone and return upon tone completion %
0000014c : 08500293;   % 333:     addi    t0, zero, 133             # ecall 33 = MIDI out synchronous %
0000014d : 11128263;   % 334:     beq     t0, a7, goToMidiOutSync %
0000014e : 03000293;   % 341:     addi    t0, zero, 48              # ecall 48 = CLS %
0000014f : 11128e63;   % 342:     beq     t0, a7, goToCLS %
00000150 : 09400293;   % 343:     addi    t0, zero, 148              # ecall 48 = CLS %
00000151 : 11128a63;   % 344:     beq     t0, a7, goToCLS %
00000152 : 00012083;   % 350: endEcall:	lw	x1, 0(sp)  # recupera QUASE todos os registradores na pilha %
00000153 : 00412103;   % 351: 	lw	    x2,   4(sp)	 %
00000154 : 00812183;   % 352: 	lw 	    x3,   8(sp)	 %
00000155 : 00c12203;   % 353: 	lw	    x4,  12(sp)      	 %
00000156 : 01012283;   % 354: 	lw	    x5,  16(sp)      	 %
00000157 : 01412303;   % 355:     lw	    x6,  20(sp)	 %
00000158 : 01812383;   % 356:     lw      x7,  24(sp) %
00000159 : 01c12403;   % 357:     lw 	    x8,  28(sp) %
0000015a : 02012483;   % 358:     lw      x9,    32(sp) %
0000015b : 02c12603;   % 361:     lw      x12,   44(sp) %
0000015c : 03012683;   % 362:     lw      x13,   48(sp) %
0000015d : 03412703;   % 363:     lw      x14,   52(sp) %
0000015e : 03812783;   % 364:     lw      x15,   56(sp) %
0000015f : 03c12803;   % 365:     lw      x16,   60(sp) %
00000160 : 04012883;   % 366:     lw      x17,   64(sp) %
00000161 : 04412903;   % 367:     lw      x18,   68(sp) %
00000162 : 04812983;   % 368:     lw      x19,   72(sp) %
00000163 : 04c12a03;   % 369:     lw      x20,   76(sp) %
00000164 : 05012a83;   % 370:     lw      x21,   80(sp) %
00000165 : 05412b03;   % 371:     lw      x22,   84(sp) %
00000166 : 05812b83;   % 372:     lw      x23,   88(sp) %
00000167 : 05c12c03;   % 373:     lw      x24,   92(sp) %
00000168 : 06012c83;   % 374:     lw      x25,   96(sp) %
00000169 : 06412d03;   % 375:     lw      x26,  100(sp) %
0000016a : 06812d83;   % 376:     lw      x27,  104(sp) %
0000016b : 06c12e03;   % 377:     lw      x28,  108(sp) %
0000016c : 07012e83;   % 378:     lw      x29,  112(sp) %
0000016d : 07412f03;   % 379:     lw      x30,  116(sp) %
0000016e : 07812f83;   % 380:     lw      x31,  120(sp) %
0000016f : 10810113;   % 414:     addi    sp, sp, 264 %
00000170 : de1ff06f;   % 415:     j endException %
00000171 : 10008237;   % 418: <70> li tp, 0x10008000			# carrega tp = 0x10008000 %
00000172 : 00020213;   % 418:  %
00000173 : 00419863;   % 418: <71> bne gp,tp,goToExitDE2 %
00000174 : 00a00893;   % 419:   		li 	a7, 10		# chama o ecall normal do Rars %
00000175 : 00000097;   % 420:   		auipc ra, 0 %
00000176 : 00408067;   % 421: 		jalr zero, ra, 4			# exit ecall %
00000177 : 06e00893;   % 424: 		li a7, 110		########### ecall 10 ou 110 %
00000178 : 00000097;   % 425: 		auipc ra, 0 %
00000179 : 00408067;   % 426: 		jalr zero, ra, 4   %
0000017a : 078000ef;   % 428: goToPrintInt:	jal     printInt               	# chama printInt %
0000017b : f5dff06f;   % 429: 		j       endEcall %
0000017c : 164000ef;   % 431: goToPrintString: jal     printString           	# chama printString %
0000017d : f55ff06f;   % 432:     		j       endEcall %
0000017e : 1a4000ef;   % 434: goToPrintChar:	jal     printChar		# chama printChar %
0000017f : f4dff06f;   % 435:     		j       endEcall %
00000180 : 548000ef;   % 437: goToPrintFloat:	jal     printFloat		# chama printFloat %
00000181 : f45ff06f;   % 438:     		j       endEcall %
00000182 : 280000ef;   % 440: goToReadChar:	jal     readChar              	# chama readChar %
00000183 : f3dff06f;   % 441:     		j       endEcall %
00000184 : 3b0000ef;   % 443: goToReadInt:   	jal     readInt                 # chama readInt %
00000185 : f35ff06f;   % 444:     		j       endEcall %
00000186 : 334000ef;   % 446: goToReadString:	jal     readString              # chama readString %
00000187 : f2dff06f;   % 447:     		j       endEcall %
00000188 : 724000ef;   % 449: goToReadFloat:	jal     readFloat               # chama readFloat %
00000189 : f25ff06f;   % 450: 		j       endEcall %
0000018a : 0b8000ef;   % 452: goToPrintHex:	jal     printHex                # chama printHex %
0000018b : f1dff06f;   % 453: 		j       endEcall %
0000018c : 410000ef;   % 455: goToMidiOut:	jal     midiOut                 # chama MIDIout %
0000018d : f15ff06f;   % 456:     		j       endEcall %
0000018e : 480000ef;   % 458: goToMidiOutSync:     	jal     midiOutSync   	# chama MIDIoutSync %
0000018f : f0dff06f;   % 459:     			j       endEcall %
00000190 : 169000ef;   % 467: goToTime:	jal     time                    # chama time %
00000191 : f05ff06f;   % 468:     		j       endEcall %
00000192 : 18d000ef;   % 470: goToSleep:	jal     sleep                  	# chama sleep %
00000193 : efdff06f;   % 471: 		j       endEcall %
00000194 : 1b9000ef;   % 473: goToRandom:	jal     random                 	# chama random %
00000195 : ef5ff06f;   % 474:     		j       endEcall %
00000196 : 1d9000ef;   % 476: goToCLS:	jal     clsCLS                 	# chama CLS %
00000197 : eedff06f;   % 477:     		j       endEcall %
00000198 : ffc10113;   % 489: printInt:	addi 	sp, sp, -4			# Aloca espaco %
00000199 : 00112023;   % 490: 		sw 	ra, 0(sp)			# salva ra %
0000019a : 0fc10297;   % 491: 		la 	t0, TempBuffer			# carrega o Endereco do Buffer da String %
0000019b : dec28293;   % 491:  %
0000019c : 00056a63;   % 493: 		bge 	a0, zero, ehposprintInt	# Se eh positvo %
0000019d : 02d00313;   % 494: 		li 	t1, '-'			# carrega o sinal - %
0000019e : 00628023;   % 495: 		sb 	t1, 0(t0)			# coloca no buffer %
0000019f : 00128293;   % 496: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
000001a0 : 40a00533;   % 497: 		sub 	a0, zero, a0			# torna o numero positivo %
000001a1 : 00a00393;   % 499: ehposprintInt:  li 	t2, 10				# carrega numero 10 %
000001a2 : 00000313;   % 500: 		li 	t1, 0				# carrega numero de digitos com 0 %
000001a3 : 02754eb3;   % 502: loop1printInt:	div 	t4, a0, t2			# divide por 10 (quociente) %
000001a4 : 02756e33;   % 503: 		rem 	t3, a0, t2			# resto %
000001a5 : ffc10113;   % 504: 		addi 	sp, sp, -4			# aloca espaco na pilha %
000001a6 : 01c12023;   % 505: 		sw 	t3, 0(sp)			# coloca resto na pilha %
000001a7 : 01d00533;   % 506: 		mv 	a0, t4			# atualiza o numero com o quociente %
000001a8 : 00130313;   % 507: 		addi 	t1, t1, 1			# incrementa o contador de digitos %
000001a9 : fe0514e3;   % 508: 		bne 	a0, zero, loop1printInt	# verifica se o numero eh zero %
000001aa : 00012383;   % 510: loop2printInt:	lw 	t2, 0(sp)			# le digito da pilha %
000001ab : 00410113;   % 511: 		addi 	sp, sp, 4			# libera espaco %
000001ac : 03038393;   % 512: 		addi 	t2, t2, 48			# converte o digito para ascii %
000001ad : 00728023;   % 513: 		sb 	t2, 0(t0)			# coloca caractere no buffer %
000001ae : 00128293;   % 514: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
000001af : fff30313;   % 515: 		addi 	t1, t1, -1			# decrementa contador de digitos %
000001b0 : fe0314e3;   % 516: 		bne 	t1, zero, loop2printInt	# eh o ultimo? %
000001b1 : 00028023;   % 517: 		sb 	zero, 0(t0)			# insere \NULL na string %
000001b2 : 0fc10517;   % 519: 		la 	a0, TempBuffer			# Endereco do buffer da srting %
000001b3 : d8c50513;   % 519:  %
000001b4 : 084000ef;   % 520: 		jal 	printString			# chama o print string %
000001b5 : 00012083;   % 522: 		lw 	ra, 0(sp)			# recupera a %
000001b6 : 00410113;   % 523: 		addi 	sp, sp, 4			# libera espaco %
000001b7 : 00008067;   % 524: fimprintInt:	ret			# retorna %
000001b8 : ffc10113;   % 536: printHex:	addi    sp, sp, -4    		# aloca espaco %
000001b9 : 00112023;   % 537:     		sw      ra, 0(sp)			# salva ra %
000001ba : 00a002b3;   % 538: 		mv 	t0, a0			# Inteiro de 32 bits a ser impresso em Hexa %
000001bb : 0fc10317;   % 539: 		la 	t1, TabelaHexASCII		# endereco da tabela HEX->ASCII %
000001bc : f6830313;   % 539:  %
000001bd : 0fc10397;   % 540: 		la 	t2, TempBuffer			# onde a string sera montada %
000001be : d6038393;   % 540:  %
000001bf : 03000e13;   % 542: 		li 	t3,'0'			# Caractere '0' %
000001c0 : 01c38023;   % 543: 		sb 	t3,0(t2)		# Escreve '0' no Buffer da String %
000001c1 : 07800e13;   % 544: 		li 	t3,'x'			# Caractere 'x' %
000001c2 : 01c380a3;   % 545: 		sb 	t3,1(t2)		# Escreve 'x' no Buffer da String %
000001c3 : 00238393;   % 546: 		addi 	t2,t2,2		# novo endereco inicial da string %
000001c4 : 01c00e13;   % 548: 		li 	t3, 28			# contador de nibble   inicio = 28 %
000001c5 : 020e4263;   % 549: loopprintHex:	blt 	t3, zero, fimloopprintHex	# terminou? t3<0? %
000001c6 : 01c2deb3;   % 550: 		srl 	t4, t0, t3		# desloca o nibble para direita %
000001c7 : 00fefe93;   % 551: 		andi 	t4, t4, 0x000F	# mascara o nibble	 %
000001c8 : 01d30eb3;   % 552: 		add 	t4, t1, t4		# endereco do ascii do nibble %
000001c9 : 000e8e83;   % 553: 		lb 	t4, 0(t4)		# le ascii do nibble %
000001ca : 01d38023;   % 554: 		sb 	t4, 0(t2)		# armazena o ascii do nibble no buffer da string %
000001cb : 00138393;   % 555: 		addi 	t2, t2, 1		# incrementa o endereco do buffer %
000001cc : ffce0e13;   % 556: 		addi 	t3, t3, -4		# decrementa o numero do nibble %
000001cd : fe1ff06f;   % 557: 		j 	loopprintHex %
000001ce : 00038023;   % 559: fimloopprintHex: sb 	zero,0(t2)		# grava \null na string %
000001cf : 0fc10517;   % 560: 		la 	a0, TempBuffer		# Argumento do print String %
000001d0 : d1850513;   % 560:  %
000001d1 : 010000ef;   % 561:     		jal	printString		# Chama o print string %
000001d2 : 00012083;   % 563: 		lw 	ra, 0(sp)		# recupera ra %
000001d3 : 00410113;   % 564: 		addi 	sp, sp, 4		# libera espaco %
000001d4 : 00008067;   % 565: fimprintHex:	ret			# retorna %
000001d5 : ff810113;   % 576: printString:	addi	sp, sp, -8			# aloca espaco %
000001d6 : 00112023;   % 577:     		sw	ra, 0(sp)			# salva ra %
000001d7 : 00812223;   % 578:     		sw	s0, 4(sp)			# salva s0 %
000001d8 : 00a00433;   % 579:     		mv	s0, a0              		# s0 = endereco do caractere na string %
000001d9 : 00040503;   % 581: loopprintString: lb	a0, 0(s0)                 	# le em a0 o caracter a ser impresso %
000001da : 02050263;   % 582:     		beq     a0, zero, fimloopprintString   # string ASCIIZ termina com NULL %
000001db : 030000ef;   % 584:     		jal     printChar       		# imprime char %
000001dc : 00858593;   % 586: 		addi    a1, a1, 8                 	# incrementa a coluna %
000001dd : 13900f93;   % 587: 		li t6, 313		 %
000001de : 01f5c663;   % 588: 		blt	a1, t6, NaoPulaLinha	    	# se ainda tiver lugar na linha %
000001df : 00860613;   % 589:     		addi    a2, a2, 8                 	# incrementa a linha %
000001e0 : 000005b3;   % 590:     		mv    a1, zero			# volta a coluna zero %
000001e1 : 00140413;   % 592: NaoPulaLinha:	addi    s0, s0, 1			# proximo caractere %
000001e2 : fddff06f;   % 593:     		j       loopprintString       		# volta ao loop %
000001e3 : 00012083;   % 595: fimloopprintString:	lw      ra, 0(sp)    		# recupera ra %
000001e4 : 00012403;   % 596: 				lw 	s0, 0(sp)			# recupera s0 original %
000001e5 : 00810113;   % 597:     			addi    sp, sp, 8		# libera espaco %
000001e6 : 00008067;   % 598: fimprintString:	ret      	    	# retorna %
000001e7 : 0ff00e93;   % 619: printChar:	 li t4, 0xFF			# t4 temporario %
000001e8 : 008e9e93;   % 620: 		slli 	t4, t4, 8			# t4 = 0x0000FF00 (no RARS, nao podemos fazer diretamente "addi rd, rs1, 0xFFF") %
000001e9 : 01d6ff33;   % 621: 		and    	t5, a3, t4   	    # t5 obtem cor de fundo %
000001ea : 0ff00e93;   % 622: 		li 		t4, 0xFF %
000001eb : 01d6ffb3;   % 623: 		and   t6, a3, t4         	# t6 obtem cor de frente %
000001ec : 008f5f13;   % 624:     	srli     t5, t5, 8			# numero da cor de fundo %
000001ed : 02000213;   % 626: 	li 	tp, ' ' %
000001ee : 00454863;   % 627: 	blt a0, tp, NAOIMPRIMIVEL		# ascii menor que 32 nao eh imprimivel %
000001ef : 07e00213;   % 628: 	li 	tp, '~' %
000001f0 : 00a24463;   % 629: 	bgt	a0, tp, NAOIMPRIMIVEL		# ascii Maior que 126  nao eh imprimivel %
000001f1 : 0080006f;   % 630:     	j       IMPRIMIVEL %
000001f2 : 02000513;   % 632: NAOIMPRIMIVEL:     li      a0, 32		# Imprime espaco %
000001f3 : 14000213;   % 634: IMPRIMIVEL:	li	tp, 320		# Num colunas 320 %
000001f4 : 02c20eb3;   % 635:     	mul     t4, tp, a2			# multiplica a2x320  t4 = coordenada y %
000001f5 : 00be8eb3;   % 636:     	add     t4, t4, a1               	# t4 = 320*y + x %
000001f6 : 007e8e93;   % 637:     	addi    t4, t4, 7                 	# t4 = 320*y + (x+7) %
000001f7 : ff000fb7;   % 638:     	li      t6, 0xFF000000          	# Endereco de inicio da memoria VGA %
000001f8 : 000f8f93;   % 638:  %
000001f9 : 01fe8eb3;   % 639:     	add     t4, t4, t6               	# t4 = endereco de impressao do ultimo pixel da primeira linha do char %
000001fa : fe050393;   % 640:     	addi    t2, a0, -32               	# indice do char na memoria %
000001fb : 00339393;   % 641:     	slli     t2, t2, 3                 	# offset em bytes em relacao ao endereco inicial %
000001fc : 0fc10e17;   % 642: 	la      t3, LabelTabChar		# endereco dos caracteres na memoria %
000001fd : 840e0e13;   % 642:  %
000001fe : 01c383b3;   % 643:     	add     t2, t2, t3               	# endereco do caractere na memoria %
000001ff : 0003ae03;   % 644: 	lw      t3, 0(t2)                 	# carrega a primeira word do char %
00000200 : 00400293;   % 645: 	li 	t0, 4				# i=4 %
00000201 : 02028e63;   % 647: forChar1I:	beq     t0, zero, endForChar1I	# if(i == 0) end for i %
00000202 : 00800313;   % 648:     		addi    t1, zero, 8               	# j = 8 %
00000203 : 02030463;   % 650: 	forChar1J:      beq     t1, zero, endForChar1J    	# if(j == 0) end for j %
00000204 : 001e7c93;   % 651:         		andi    s9, t3, 0x0001		# primeiro bit do caracter %
00000205 : 001e5e13;   % 652:         		srli     t3, t3, 1             	# retira o primeiro bit %
00000206 : 000c8663;   % 653:         		beq     s9, zero, printCharPixelbg1	# pixel eh fundo? %
00000207 : 01fe8023;   % 654:         		sb      t6, 0(t4)             	# imprime pixel com cor de frente %
00000208 : 0080006f;   % 655:         		j       endCharPixel1 %
00000209 : 01ee8023;   % 656: printCharPixelbg1:     	sb      t5, 0(t4)                 	# imprime pixel com cor de fundo %
0000020a : fff30313;   % 657: endCharPixel1:     	addi    t1, t1, -1                	# j-- %
0000020b : fffe8e93;   % 658:     			addi    t4, t4, -1                	# t4 aponta um pixel para a esquerda %
0000020c : fddff06f;   % 659:     			j       forChar1J			# vollta novo pixel %
0000020d : fff28293;   % 661: endForChar1J: 	addi    t0, t0, -1 		# i-- %
0000020e : 148e8e93;   % 662:     		addi    t4, t4, 328           # 2**12 + 8 %
0000020f : fc9ff06f;   % 663:     		j       forChar1I		# volta ao loop %
00000210 : 0043ae03;   % 665: endForChar1I:	lw      t3, 4(t2)           	# carrega a segunda word do char %
00000211 : 00400293;   % 666: 		li 	t0, 4			# i = 4 %
00000212 : 02028e63;   % 667: forChar2I:     	beq     t0, zero, endForChar2I    	# if(i == 0) end for i %
00000213 : 00800313;   % 668:     		addi    t1, zero, 8               # j = 8 %
00000214 : 02030463;   % 670: 	forChar2J:	beq	t1, zero, endForChar2J    	# if(j == 0) end for j %
00000215 : 001e7c93;   % 671:         		andi    s9, t3, 0x0001	    	# pixel a ser impresso %
00000216 : 001e5e13;   % 672:         		srli     t3, t3, 1                 	# desloca para o proximo %
00000217 : 000c8663;   % 673:         		beq     s9, zero, printCharPixelbg2	# pixel eh fundo? %
00000218 : 01fe8023;   % 674:         		sb      t6, 0(t4)			# imprime cor frente %
00000219 : 0080006f;   % 675:         		j       endCharPixel2			# volta ao loop %
0000021a : 01ee8023;   % 677: printCharPixelbg2:     	sb      t5, 0(t4)			# imprime cor de fundo %
0000021b : fff30313;   % 679: endCharPixel2:     	addi    t1, t1, -1			# j-- %
0000021c : fffe8e93;   % 680:     			addi    t4, t4, -1                	# t4 aponta um pixel para a esquerda %
0000021d : fddff06f;   % 681:     			j       forChar2J %
0000021e : fff28293;   % 683: endForChar2J:	addi	t0, t0, -1 		# i-- %
0000021f : 148e8e93;   % 684:     		addi    t4, t4, 328		# %
00000220 : fc9ff06f;   % 685:     		j       forChar2I		# volta ao loop %
00000221 : 00008067;   % 687: endForChar2I:	ret				# retorna %
00000222 : 10008237;   % 696: <70> li tp, 0x10008000			# carrega tp = 0x10008000 %
00000223 : 00020213;   % 696:  %
00000224 : 02419063;   % 696: <71> bne gp,tp,readCharKDMMIODE2 %
00000225 : ff2002b7;   % 699: readCharKDMMIO:		li 	t0, 0xFF200000			# Execucao com Polling do KD MMIO %
00000226 : 00028293;   % 699:  %
00000227 : 0002a503;   % 701: loopReadCharKDMMIO:  	lw     	a0, 0(t0)   			# le o bit de flag do teclado %
00000228 : 00157513;   % 702: 			andi 	a0, a0, 0x0001		# masacara bit 0 %
00000229 : fe050ce3;   % 703: 			beq     a0, zero, loopReadCharKDMMIO  # testa se uma tecla foi pressionada %
0000022a : 0042a503;   % 704:     			lw 	a0, 4(t0)			# le o ascii da tecla pressionada %
0000022b : 09c0006f;   % 705: 			j fimreadChar				# fim Read Char %
0000022c : ff2002b7;   % 709: readCharKDMMIODE2:	li 	t0, 0xFF200000			# Execucao com Polling do KD MMIO %
0000022d : 00028293;   % 709:  %
0000022e : 0002a503;   % 711: loopReadCharKDMMIODE2: 	lw     	a0, 0(t0)   			# le o bit de flag do teclado %
0000022f : 00157513;   % 712: 			andi 	a0, a0, 0x0001		# masacara bit 0 %
00000230 : fe050ce3;   % 713: 			beq     a0, zero, loopReadCharKDMMIODE2  # testa se uma tecla foi pressionada %
00000231 : 0042a503;   % 714:     			lw 	a0, 4(t0)			# le o ascii da tecla pressionada %
00000232 : 0800006f;   % 715: 			j fimreadChar				# fim Read Char %
00000233 : ff2002b7;   % 722: readCharDE2:  	li      t0, 0xFF200100 			# Endereco buffer0 %
00000234 : 10028293;   % 722:  %
00000235 : 0002a303;   % 723:     		lw     	t1, 0(t0)				# conteudo inicial do buffer %
00000236 : 0002a383;   % 725: loopReadChar:  	lw     	t2, 0(t0)   				# le buffer teclado %
00000237 : 00639663;   % 726: 		bne     t2, t1, buffermodificadoChar    	# testa se o buffer foi modificado %
00000238 : 00700333;   % 728: atualizaBufferChar:  mv t1, t2			# atualiza o buffer com o novo valor %
00000239 : ff5ff06f;   % 729:     	j       loopReadChar				# loop de printicpal de leitura  %
0000023a : 0ff00f13;   % 731: buffermodificadoChar:	li t5, 0xFF %
0000023b : 008f1f13;   % 732: 						slli t5, t5, 8			# t5 = 0x0000FF00 %
0000023c : 01e3fe33;   % 733: 	and    t3, t2, t5 						# mascara o 2o scancode %
0000023d : 0000f237;   % 734: 	li 	tp, 0x0000F000 %
0000023e : 00020213;   % 734:  %
0000023f : 024e0063;   % 735: 	beq     t3, tp, teclasoltaChar		# eh 0xF0 no 2o scancode? tecla foi solta %
00000240 : 0ff00213;   % 736: 	li	tp, 0x000000FF %
00000241 : 0043fe33;   % 737: 	and	t3, t2, tp				# mascara 1o scancode	(essa podemos fazer diretamente) %
00000242 : 01200213;   % 738: 	li	tp, 0x00000012 %
00000243 : fc4e1ae3;   % 739:     	bne 	t3, tp, atualizaBufferChar		# nao eh o SHIFT que esta pressionado ? volta a ler  %
00000244 : 0fc10417;   % 740: 	la      s0, LabelScanCodeShift			# se for SHIFT que esta pressionado atualiza o endereco da tabel %
00000245 : abe40413;   % 740:  %
00000246 : fc9ff06f;   % 741:     	j       atualizaBufferChar			# volta a ler %
00000247 : 0ff3fe13;   % 743: teclasoltaChar:		andi t3, t2, 0x00FF		# mascara o 1o scancode %
00000248 : 08000213;   % 744: 	li	tp, 0x00000080 %
00000249 : fbc24ee3;   % 745:   	bgt	t3, tp, atualizaBufferChar		# se o scancode for > 0x80 entao nao eh imprimivel! %
0000024a : 01200213;   % 746:   	li	tp, 0x00000012 %
0000024b : 004e1863;   % 747: 	bne 	t3, tp, naoehshiftChar		# nao foi o shift que foi solto? entao processa %
0000024c : 0fc10417;   % 748: 	la 	s0, LabelScanCode			# shift foi solto atualiza o endereco da tabela %
0000024d : a1840413;   % 748:  %
0000024e : fa9ff06f;   % 749: 	j 	atualizaBufferChar			# volta a ler %
0000024f : 01c40e33;   % 751: naoehshiftChar:	   	add     t3, s0, t3                   	# endereco na tabela de scancode da tecla com ou sem shift %
00000250 : 000e0503;   % 752:     	lb      a0, 0(t3)				# le o ascii do caracter para a0 %
00000251 : f8050ee3;   % 753:     	beq     a0, zero, atualizaBufferChar		# se for caractere nao imprimivel volta a ler %
00000252 : 00008067;   % 755: fimreadChar: 	ret			# retorna %
00000253 : ff810113;   % 767: readString: 	addi 	sp, sp, -8			# reserva espaco na pilha %
00000254 : 00812223;   % 768: 		sw 	s0, 4(sp)			# salva s0 %
00000255 : 00112023;   % 769: 		sw 	ra, 0(sp)			# salva ra %
00000256 : 00000693;   % 770: 		li 	a3, 0				# zera o contador de caracteres digitados %
00000257 : 00a00933;   % 771: 		mv 	s2, a0				# salva o endereço inicial %
00000258 : 0fc10417;   % 772:     		la      s0, LabelScanCode      	# Endereco da tabela de scancode inicial para readChar %
00000259 : 9e840413;   % 772:  %
0000025a : 02d58e63;   % 774: loopreadString: beq 	a1, a3, fimreadString   	# buffer cheio fim %
0000025b : ff810113;   % 776: 		addi sp, sp, -8 %
0000025c : 00112023;   % 777: 		sw ra, 0(sp)				# salva ra %
0000025d : 00a12223;   % 778: 		sw a0, 4(sp)				# salva a0 pois ele sera reescrito em readChar %
0000025e : f11ff0ef;   % 779: 		jal 	readChar			# le um caracter do teclado (retorno em a0) %
0000025f : 00a00fb3;   % 780: 		mv 	t6, a0					# t6 eh a letra lida em readChar %
00000260 : 00012083;   % 781: 		lw ra, 0(sp) %
00000261 : 00412503;   % 782: 		lw a0, 4(sp) %
00000262 : 00810113;   % 783: 		addi sp, sp, 8 %
00000263 : 00a00213;   % 785: 		li	tp, 0x0A %
00000264 : 004f8a63;   % 786: 		beq 	t6, tp, fimreadString	# se for tecla ENTER fim %
00000265 : 01f50023;   % 787: 		sb 	t6, 0(a0)			# grava no buffer %
00000266 : 00168693;   % 788: 		addi 	a3, a3, 1			# incrementa contador %
00000267 : 00150513;   % 789: 		addi 	a0, a0, 1			# incrementa endereco no buffer %
00000268 : fc9ff06f;   % 790: 		j loopreadString			# volta a ler outro caractere %
00000269 : 00050023;   % 792: fimreadString: 	sb 	zero, 0(a0)			# grava NULL no buffer %
0000026a : fff50613;   % 793: 		addi 	a2, a0, -1			# Para que a2 tenha o endereco do ultimo caractere digitado %
0000026b : 01200533;   % 794: 		mv	a0, s2				# a0 volta a ter o endereço inicial da string %
0000026c : 00012083;   % 795: 		lw 	ra, 0(sp)			# recupera ra %
0000026d : 00412403;   % 796: 		lw	s0, 4(sp)			# recupera s0 %
0000026e : 00810113;   % 797: 		addi 	sp, sp, 8			# libera espaco %
0000026f : 00008067;   % 798: 		ret						# retorna %
00000270 : ffc10113;   % 807: readInt: 	addi 	sp,sp,-4		# reserva espaco na pilha %
00000271 : 00112023;   % 808: 	sw 	ra, 0(sp)			# salva ra %
00000272 : 0fc10517;   % 809: 	la 	a0, TempBuffer			# Endereco do buffer de string %
00000273 : a8c50513;   % 809:  %
00000274 : 00a00593;   % 810: 	li 	a1, 10				# numero maximo de digitos %
00000275 : f79ff0ef;   % 811: 	jal 	readString			# le uma string de ate 10 digitos, a3 numero de digitos %
00000276 : 00c002b3;   % 812: 	mv 	t0, a2			# copia endereco do ultimo digito %
00000277 : 00a00393;   % 813: 	li 	t2, 10				# dez %
00000278 : 00100e13;   % 814: 	li 	t3, 1				# dezenas, centenas, etc %
00000279 : 00000533;   % 815: 	mv 	a0, zero			# zera o numero %
0000027a : 04068663;   % 817: loopReadInt: 	beq	a3,zero, fimReadInt	# Leu todos os digitos %
0000027b : 00028303;   % 818: 	lb 	t1, (t0)			# le um digito %
0000027c : 02d00213;   % 819: 	li	tp, 0x0000002D %
0000027d : 02430e63;   % 820: 	beq 	t1, tp, ehnegReadInt		# = '-' %
0000027e : 02b00213;   % 821: 	li	tp, 0x0000002B %
0000027f : 02430c63;   % 822: 	beq 	t1, tp, ehposReadInt		# = '+' %
00000280 : 03000213;   % 823: 	li	tp, 0x00000030 %
00000281 : 02434463;   % 824: 	blt 	t1, tp, naoehReadInt		# <'0' %
00000282 : 03900213;   % 825: 	li	tp, 0x00000039 %
00000283 : 02624063;   % 826: 	bgt 	t1, tp, naoehReadInt		# >'9' %
00000284 : fd030313;   % 827: 	addi 	t1, t1, -48			# transforma ascii em numero %
00000285 : 03c30333;   % 828: 	mul 	t1, t1, t3			# multiplica por dezenas/centenas %
00000286 : 00650533;   % 829: 	add 	a0, a0, t1			# soma no numero %
00000287 : 027e0e33;   % 830: 	mul 	t3, t3, t2			# proxima dezena/centena %
00000288 : fff28293;   % 831: 	addi 	t0, t0, -1			# busca o digito anterior %
00000289 : fff68693;   % 832: 	addi	a3, a3, -1			# reduz o contador de digitos  %
0000028a : fc1ff06f;   % 833: 	j loopReadInt				# volta para buscar proximo digito %
0000028b : 0080006f;   % 836: 				j fimReadInt				# como nao esta implmentado apenas retorna %
0000028c : 40a00533;   % 838: ehnegReadInt:	sub a0,zero,a0		# se for negativo %
0000028d : 00012083;   % 842: fimReadInt:	lw 	ra, 0(sp)		# recupera ra %
0000028e : 00410113;   % 843: 	addi 	sp, sp, 4			# libera espaco %
0000028f : 00008067;   % 844: 	ret							# fim ReadInt %
00000290 : 10008237;   % 863: <70> li tp, 0x10008000			# carrega tp = 0x10008000 %
00000291 : 00020213;   % 863:  %
00000292 : 00419863;   % 863: <71> bne gp,tp,midiOutDE2 %
00000293 : 01f00893;   % 864: 	li a7,31		# Chama o ecall normal %
00000294 : 00000073;   % 865: 	ecall %
00000295 : 0600006f;   % 866: 	j fimmidiOut %
00000296 : ff2002b7;   % 868: midiOutDE2:	li      t0, 0xFF200178 %
00000297 : 17828293;   % 868:  %
00000298 : 00000333;   % 869:     		add     t1, zero, zero %
00000299 : 00f67393;   % 874:    	 	andi    t2, a2, 0x0000000F %
0000029a : 01b39393;   % 875:     		slli     t2, t2, 27 %
0000029b : 00736333;   % 876:     		or      t1, t1, t2 %
0000029c : 07f6f393;   % 879:     		andi    t2, a3, 0x0000007F %
0000029d : 01439393;   % 880:     		slli     t2, t2, 20 %
0000029e : 00736333;   % 881:     		or      t1, t1, t2 %
0000029f : 07f57393;   % 884:     		andi    t2, a0, 0x0000007F %
000002a0 : 00d39393;   % 885:     		slli     t2, t2, 13 %
000002a1 : 00736333;   % 886:     		or      t1, t1, t2 %
000002a2 : 1ff00e93;   % 889: 			li t4, 0x1FF %
000002a3 : 004e9e93;   % 890: 			slli t4, t4, 4 %
000002a4 : 00fe8e93;   % 891: 			addi t4, t4, 0xF			# t4 = 0x00001FFF %
000002a5 : 01d5f3b3;   % 892:     		and    t2, a1, t4 %
000002a6 : 00736333;   % 893:     		or      t1, t1, t2 %
000002a7 : 0040006f;   % 896:     		j       SintMidOut %
000002a8 : 0062a023;   % 898: SintMidOut:	sw	t1, 0(t0) %
000002a9 : ff2003b7;   % 901: 	    		li      t2, 0xFF20017C %
000002aa : 17c38393;   % 901:  %
000002ab : 0003ae03;   % 902: Check_AUD_DACLRCK:     	lw      t3, 0(t2) %
000002ac : fe0e0ee3;   % 903:     			beq     t3, zero, Check_AUD_DACLRCK %
000002ad : 00008067;   % 905: fimmidiOut:    		ret %
000002ae : 10008237;   % 922: <70> li tp, 0x10008000			# carrega tp = 0x10008000 %
000002af : 00020213;   % 922:  %
000002b0 : 00419863;   % 922: <71> bne gp,tp,midiOutSyncDE2 %
000002b1 : 02100893;   % 923: 	li a7,33		# Chama o ecall normal %
000002b2 : 00000073;   % 924: 	ecall %
000002b3 : 0780006f;   % 925: 	j fimmidiOutSync %
000002b4 : ff2002b7;   % 927: midiOutSyncDE2:	li      t0, 0xFF200178 %
000002b5 : 17828293;   % 927:  %
000002b6 : 00000333;   % 928:     		add     t1, zero, zero %
000002b7 : 08000337;   % 931:     		lui    t1, 0x08000 %
000002b8 : 00431313;   % 932: 			slli	t1, t1, 4			# t1 = 0x80000000 %
000002b9 : 00f67393;   % 935:     		andi    t2, a2, 0x0000000F %
000002ba : 01b39393;   % 936:     		slli     t2, t2, 27 %
000002bb : 00736333;   % 937:     		or      t1, t1, t2 %
000002bc : 07f6f393;   % 940:     		andi    t2, a3, 0x0000007F %
000002bd : 01439393;   % 941:     		slli     t2, t2, 20 %
000002be : 00736333;   % 942:     		or      t1, t1, t2 %
000002bf : 07f57393;   % 945:     		andi    t2, a0, 0x0000007F %
000002c0 : 00d39393;   % 946:     		slli     t2, t2, 13 %
000002c1 : 00736333;   % 947:     		or      t1, t1, t2 %
000002c2 : 1ff00e93;   % 950: 			li t4, 0x1FF %
000002c3 : 004e9e93;   % 951: 			slli t4, t4, 4 %
000002c4 : 00fe8e93;   % 952: 			addi t4, t4, 0xF			# t4 = 0x00001FFF %
000002c5 : 01d5f3b3;   % 953:     		and    t2, a1, t4 %
000002c6 : 00736333;   % 954:     		or      t1, t1, t2 %
000002c7 : 0040006f;   % 957:     		j       SintMidOutSync %
000002c8 : 0062a023;   % 959: SintMidOutSync:	sw	t1, 0(t0) %
000002c9 : ff2003b7;   % 962:     		li      t2, 0xFF20017C %
000002ca : 17c38393;   % 962:  %
000002cb : ff200eb7;   % 963:     		li      t4, 0xFF200180 %
000002cc : 180e8e93;   % 963:  %
000002cd : 0003ae03;   % 965: Check_AUD_DACLRCKSync:	lw      t3, 0(t2) %
000002ce : fe0e0ee3;   % 966:     			beq     t3, zero, Check_AUD_DACLRCKSync %
000002cf : 000eaf03;   % 968: Melody:     	lw      t5, 0(t4) %
000002d0 : fe0f1ee3;   % 969:     		bne     t5, zero, Melody %
000002d1 : 00008067;   % 971: fimmidiOutSync:	ret %
000002d2 : ffc10113;   % 1017: printFloat:	addi 	sp, sp, -4 %
000002d3 : 00112023;   % 1018: 		sw 	ra, 0(sp)				# salva ra %
000002d4 : 0fc10417;   % 1019: 		la 	s0, TempBuffer %
000002d5 : 90440413;   % 1019:  %
000002d6 : 02b00293;   % 1022: 		li 	t0, '+'			# define sinal '+' %
000002d7 : e00504d3;   % 1023: 		fmv.x.s 	s1, fa0			# recupera o numero float sem conversao %
000002d8 : 00800393;   % 1024: 		li		t2, 0x8 %
000002d9 : 01c29393;   % 1025: 		slli	t2, t0, 28			# move o 8 pro final %
000002da : 0074f4b3;   % 1026: 		and 	s1, s1, t2		# mascara com 1000 %
000002db : 00048663;   % 1027: 		beq 	s1, zero, ehposprintFloat	# eh positivo s1=0 %
000002dc : 00100493;   % 1028: 		li 	s1, 1				# numero eh negativo s1=1 %
000002dd : 02d00293;   % 1029: 		li 	t0, '-'			# define sinal '-' %
000002de : 00540023;   % 1030: ehposprintFloat: sb 	t0, 0(s0)			# coloca sinal no buffer %
000002df : 00140413;   % 1031: 		addi 	s0, s0,1			# incrementa o endereco do buffer %
000002e0 : e00502d3;   % 1034: 		 fmv.x.s 	t0, fa0			# recupera o numero float sem conversao %
000002e1 : 7f800337;   % 1035: 		 lui	t1, 0x7F800 %
000002e2 : 0062f2b3;   % 1036: 		 and 	t0, t0, t1   		# mascara com 0111 1111 1000 0000 0000 0000... %
000002e3 : 00129293;   % 1037: 		 slli 	t0, t0, 1			# tira o sinal do numero %
000002e4 : 0182d293;   % 1038: 		 srli 	t0, t0, 24			# recupera o expoente %
000002e5 : e0050353;   % 1041: 		fmv.x.s 	t1, fa0			# recupera o numero float sem conversao %
000002e6 : 7ffff3b7;   % 1042: 		lui 	t2, 0x7FFFF %
000002e7 : 0083d393;   % 1043: 		srli	t2, t2, 8 %
000002e8 : 00f38393;   % 1044: 		addi	t2, t2, 0xF				# t2 = 0x007FFFFF %
000002e9 : 00737333;   % 1045: 		and 	t1, t1, t2		# mascara com 0000 0000 0111 1111 1111... 		  %
000002ea : 14028063;   % 1047: 		beq 	t0, zero, ehExp0printFloat	# Expoente = 0 %
000002eb : 0ff00213;   % 1048: 		li	tp, 0x000000FF			# TP = 255 %
000002ec : 16428063;   % 1049: 		beq 	t0, tp, ehExp255printFloat	# Expoente = 255 %
000002ed : 20a52053;   % 1053: 		fabs.s 	ft0, fa0		# ft0 recebe o modulo  de x %
000002ee : 00100213;   % 1054: 		li		tp, 1 %
000002ef : d00270d3;   % 1055: 		fcvt.s.w ft1, tp		# ft1 recebe o numero 1.0 %
000002f0 : 00a00213;   % 1056: 		li		tp, 10 %
000002f1 : d0027353;   % 1057: 		fcvt.s.w ft6, tp		# ft6 recebe o numero 10.0 %
000002f2 : 00100213;   % 1058: 		li		tp, 1 %
000002f3 : d00273d3;   % 1059: 		fcvt.s.w ft7, tp %
000002f4 : 00200213;   % 1060: 		li		tp, 2 %
000002f5 : d0027e53;   % 1061: 		fcvt.s.w ft8, tp %
000002f6 : 19c3f3d3;   % 1062: 		fdiv.s	ft7, ft7, ft8	# ft7 recebe o numero 0.5 %
000002f7 : a0101ed3;   % 1065: 		flt.s 	t4, ft0, ft1		# ft0 < 1.0 ? Se sim, E deve ser negativo %
000002f8 : 000e9663;   % 1066: 		bnez	t4, menor1printFloat	# se a comparacao deu true (1), pula %
000002f9 : 20630153;   % 1067: 		fmv.s 	ft2, ft6		# ft2  fator de multiplica�ao = 10 %
000002fa : 02c0006f;   % 1068: 		j 	cont2printFloat		# vai para expoente positivo %
000002fb : 1860f153;   % 1069: menor1printFloat: fdiv.s ft2,ft1,ft6		# ft2 fator multiplicativo = 0.1 %
000002fc : 20000253;   % 1072: cont1printFloat: 	fmv.s 	ft4, ft0			# inicia com o numero x  %
000002fd : 201081d3;   % 1073: 		 	fmv.s 	ft3, ft1			# contador come�a em 1 %
000002fe : 18227253;   % 1074: loop1printFloat: 	fdiv.s 	ft4, ft4, ft2			# divide o numero pelo fator multiplicativo %
000002ff : a0120e53;   % 1075: 		 	fle.s 	t3, ft4, ft1			# o numero eh > que 1? entao fim %
00000300 : 000e0663;   % 1076: 		 	beqz 	t3, fimloop1printFloat %
00000301 : 0011f1d3;   % 1077: 		 	fadd.s 	ft3, ft3, ft1			# incrementa o contador %
00000302 : ff1ff06f;   % 1078: 		 	j 	loop1printFloat			# volta ao loop %
00000303 : 18227253;   % 1079: fimloop1printFloat: 	fdiv.s 	ft4, ft4, ft2			# ajusta o numero %
00000304 : 0200006f;   % 1080: 		 	j 	intprintFloat			# vai para imprimir a parte inteira %
00000305 : 20000253;   % 1083: cont2printFloat:	fmv.s 	ft4, ft0			# inicia com o numero x  %
00000306 : d00071d3;   % 1084: 		 	fcvt.s.w 	ft3, zero		# contador come�a em 0 %
00000307 : a0621e53;   % 1085: loop2printFloat:  	flt.s 	t3, ft4, ft6			# resultado eh < que 10? entao fim %
00000308 : 000e1863;   % 1086: 			bnez 	t3 ,intprintFloat %
00000309 : 18227253;   % 1087: 			fdiv.s 	ft4, ft4, ft2			# divide o numero pelo fator multiplicativo %
0000030a : 0011f1d3;   % 1088: 		 	fadd.s 	ft3, ft3, ft1			# incrementa o contador %
0000030b : ff1ff06f;   % 1089: 		 	j 	loop2printFloat %
0000030c : 08727253;   % 1096: 			fsub.s		ft4, ft4, ft7	# tira 0.5, dessa forma sempre ao converter estaremos fazendo floor %
0000030d : c00272d3;   % 1097: 		  	fcvt.w.s		t0, ft4		# coloca floor de ft4 em t0 %
0000030e : 00727253;   % 1098: 			fadd.s		ft4, ft4, ft7	# readiciona 0.5 %
0000030f : 03028293;   % 1099: 		  	addi 		t0, t0, 48		# converte para ascii %
00000310 : 00540023;   % 1100: 		  	sb 		t0, 0(s0)		# coloca no buffer %
00000311 : 00140413;   % 1101: 		  	addi 		s0, s0, 1		# incrementta o buffer %
00000312 : 02e00293;   % 1104: 		  	li 	t0, '.'				# carrega o '.' %
00000313 : 00540023;   % 1105: 		  	sb 	t0, 0(s0)			# coloca no buffer %
00000314 : 00140413;   % 1106: 		  	addi 	s0, s0, 1			# incrementa o buffer %
00000315 : 00800313;   % 1109: 		  	li 		t1, 8				# contador de digitos  -  8 casas decimais %
00000316 : 04030063;   % 1110: loopfracprintFloat:  	beq t1, zero, fimfracprintFloat			# fim dos digitos? %
00000317 : 08727253;   % 1111: 			fsub.s		ft4, ft4, ft7		# tira 0.5 %
00000318 : c0027f53;   % 1112: 			fcvt.w.s 	t5, ft4				# floor de ft4 %
00000319 : 00727253;   % 1113: 			fadd.s		ft4, ft4, ft7		# readiciona 0.5 %
0000031a : d00f72d3;   % 1114: 			fcvt.s.w	ft5, t5				# reconverte em float so com a parte inteira %
0000031b : 085272d3;   % 1115: 		  	fsub.s 		ft5, ft4, ft5			# parte fracionaria %
0000031c : 1062f2d3;   % 1116: 		  	fmul.s 		ft5, ft5, ft6			# mult x 10 %
0000031d : 0872f2d3;   % 1117: 			fsub.s		ft5, ft5, ft7		# tira 0.5 %
0000031e : c002f2d3;   % 1118: 			fcvt.w.s	t0, ft5				# coloca floor de ft5 em 10 %
0000031f : 03028293;   % 1119: 		  	addi 		t0, t0, 48			# converte para ascii %
00000320 : 00540023;   % 1120: 		  	sb 		t0, 0(s0)			# coloca no buffer %
00000321 : 00140413;   % 1121: 		  	addi 		s0, s0, 1			# incrementa endereco %
00000322 : fff30313;   % 1122: 		  	addi 		t1, t1, -1			# decrementa contador %
00000323 : 0072f2d3;   % 1123: 			fadd.s		ft5, ft5, ft7		# reincrementa 0.5 %
00000324 : 20528253;   % 1124: 		  	fmv.s 		ft4, ft5			# coloca o numero em ft4 %
00000325 : fc5ff06f;   % 1125: 		  	j 		loopfracprintFloat		# volta ao loop %
00000326 : 04500293;   % 1128: fimfracprintFloat: 	li 	t0,'E'			# carrega 'E' %
00000327 : 00540023;   % 1129: 			sb 	t0, 0(s0)		# coloca no buffer %
00000328 : 00140413;   % 1130: 			addi 	s0, s0, 1		# incrementa endereco %
00000329 : 02b00293;   % 1133: 		  	li 	t0, '+'				# carrega '+' %
0000032a : 000e8463;   % 1134: 		  	beqz 	t4, expposprintFloat		# nao eh negativo? %
0000032b : 02d00293;   % 1135: 		  	li 	t0, '-'				# carrega '-' %
0000032c : 00540023;   % 1136: expposprintFloat: 	sb 	t0, 0(s0)			# coloca no buffer %
0000032d : 00140413;   % 1137: 		  	addi 	s0, s0, 1			#incrementa endereco %
0000032e : 00a00313;   % 1140: 			li 	t1, 10				# carrega 10	 %
0000032f : c001f2d3;   % 1141: 			fcvt.w.s 	t0, ft3			# passa ft3 para t0 %
00000330 : 0262c2b3;   % 1142: 			div 	t0, t0, t1			# divide por 10 (dezena) %
00000331 : 0262e3b3;   % 1143: 			rem	t2, t0, t1			# t0 = quociente, t2 = resto %
00000332 : 03028293;   % 1144: 			addi 	t0, t0, 48			# converte para ascii %
00000333 : 00540023;   % 1145: 			sb 	t0, 0(s0)			# coloca no buffer %
00000334 : 03038393;   % 1146: 			addi 	t2, t2, 48			# converte para ascii %
00000335 : 007400a3;   % 1147: 			sb 	t2, 1(s0)			# coloca no buffer %
00000336 : 00040123;   % 1148: 			sb 	zero, 2(s0)			# insere \NULL da string %
00000337 : 0fc0f517;   % 1149: 			la 	a0, TempBuffer			# endereco do Buffer										 %
00000338 : 77850513;   % 1149:  %
00000339 : 0500006f;   % 1150: 	  		j 	fimprintFloat			# imprime a string %
0000033a : 00030e63;   % 1152: ehExp0printFloat: 	beq 	t1, zero, eh0printFloat		# Verifica se eh zero %
0000033b : 0fc10517;   % 1154: ehDesnormprintFloat: 	la 	a0, NumDesnormP			# string numero desnormalizado positivo %
0000033c : 97b50513;   % 1154:  %
0000033d : 04048063;   % 1155: 			beq 	s1, zero, fimprintFloat		# o sinal eh 1? entao � negativo %
0000033e : 0fc10517;   % 1156: 		 	la 	a0, NumDesnormN			# string numero desnormalizado negativo %
0000033f : 97850513;   % 1156:  %
00000340 : 0340006f;   % 1157: 			j 	fimprintFloat			# imprime a string %
00000341 : 0fc10517;   % 1159: eh0printFloat:		la 	a0, NumZero			# string do zero %
00000342 : 97550513;   % 1159:  %
00000343 : 0280006f;   % 1160: 			j 	fimprintFloat 	 		# imprime a string %
00000344 : 00030863;   % 1162: ehExp255printFloat: 	beq 	t1, zero, ehInfprintFloat	# se mantissa eh zero entao eh Infinito %
00000345 : 0fc10517;   % 1164: ehNaNprintfFloat:	la 	a0, NumNaN			# string do NaN %
00000346 : 98450513;   % 1164:  %
00000347 : 0180006f;   % 1165: 			j 	fimprintFloat			# imprime string %
00000348 : 0fc10517;   % 1167: ehInfprintFloat:	la 	a0, NumInfP			# string do infinito positivo %
00000349 : 96450513;   % 1167:  %
0000034a : 00048663;   % 1168: 			beq 	s1, zero, fimprintFloat		# o sinal eh 1? entao eh negativo %
0000034b : 0fc10517;   % 1169: 			la 	a0, NumInfN			# string do infinito negativo %
0000034c : 96250513;   % 1169:  %
0000034d : a21ff0ef;   % 1172: fimprintFloat:		jal 	printString			# imprime a string em a0 %
0000034e : 00012083;   % 1173: 			lw 	ra, 0(sp)			# recupera ra %
0000034f : 00410113;   % 1174: 			addi 	sp, sp, 4			# libera sepaco %
00000350 : 00008067;   % 1175: 			ret					# retorna %
00000351 : ffc10113;   % 1184: readFloat: addi sp, sp, -4			# aloca espaco %
00000352 : 00112023;   % 1185: 	sw 	ra, 0(sp)			# salva ra %
00000353 : 0fc0f517;   % 1186: 	la 	a0, TempBuffer			# endereco do FloatBuffer %
00000354 : 70850513;   % 1186:  %
00000355 : 02000593;   % 1187: 	li 	a1, 32				# numero maximo de caracteres %
00000356 : bf5ff0ef;   % 1188: 	jal	readString			# le string, retorna a2 ultimo endereco e a3 numero de caracteres %
00000357 : 00c00433;   % 1189: 	mv 	s0, a2			# ultimo endereco da string (antes do \0) %
00000358 : 00d004b3;   % 1190: 	mv 	s1, a3			# numero de caracteres digitados %
00000359 : 0fc0fb97;   % 1191: 	la	s7, TempBuffer			# Endereco do primeiro caractere %
0000035a : 6f0b8b93;   % 1191:  %
0000035b : 017002b3;   % 1193: lePrimeiroreadFloat:	mv 	t0, s7		# Endereco de Inicio %
0000035c : 00028303;   % 1194: 	lb 	t1, 0(t0)				# le primeiro caractere %
0000035d : 06500213;   % 1195: 	li	tp, 'e'					# TP = 101 = 'e' %
0000035e : 02430863;   % 1196: 	beq 	t1, tp, insere0AreadFloat		# insere '0' antes %
0000035f : 04500213;   % 1197: 	li 	tp, 'E'					# TP = 69 = 'E' %
00000360 : 02430463;   % 1198: 	beq 	t1, tp, insere0AreadFloat		# insere '0' antes %
00000361 : 02e00213;   % 1199: 	li	tp, '.'					# TP = 46 = '.' %
00000362 : 02430063;   % 1200: 	beq 	t1, tp, insere0AreadFloat		#  insere '0' antes %
00000363 : 02b00213;   % 1201: 	li	tp, '+'					# TP = 43 = '+' %
00000364 : 00430863;   % 1202: 	beq 	t1, tp, pulaPrimreadChar		# pula o primeiro caractere %
00000365 : 02d00213;   % 1203: 	li	tp, '-'					# TP = 45 = '-' %
00000366 : 00430463;   % 1204: 	beq 	t1, tp, pulaPrimreadChar %
00000367 : 03c0006f;   % 1205: 	j leUltimoreadFloat %
00000368 : 001b8b93;   % 1207: pulaPrimreadChar: addi s7,s7,1		# incrementa o endereco inicial %
00000369 : fc9ff06f;   % 1208: 		  j lePrimeiroreadFloat		# volta a testar o novo primeiro caractere %
0000036a : 008002b3;   % 1210: insere0AreadFloat: mv t0, s0		# endereco do ultimo caractere %
0000036b : 00140413;   % 1211: 		   addi s0, s0, 1		# desloca o ultimo endereco para o proximo %
0000036c : 00148493;   % 1212: 	   	   addi s1, s1, 1		# incrementa o num. caracteres %
0000036d : 000400a3;   % 1213: 	   	   sb 	zero, 1(s0)		# \NULL do final de string %
0000036e : 01700f33;   % 1214: 	   	   mv t5, s7		# primeiro caractere %
0000036f : 01e28a63;   % 1215: insere0Aloop:	   beq 	t0, t5, saiinsere0AreadFloat	# chegou no inicio entao fim %
00000370 : 00028303;   % 1216: 		   lb 	t1, 0(t0)		# le caractere %
00000371 : 006280a3;   % 1217: 		   sb 	t1, 1(t0)		# escreve no proximo %
00000372 : fff28293;   % 1218: 		   addi t0, t0, -1		# decrementa endereco %
00000373 : ff1ff06f;   % 1219: 		   j insere0Aloop		# volta ao loop %
00000374 : 03000313;   % 1220: saiinsere0AreadFloat: li t1, '0'		# ascii '0' %
00000375 : 00628023;   % 1221: 		   sb t1, 0(t0)		# escreve '0' no primeiro caractere %
00000376 : 00040303;   % 1223: leUltimoreadFloat: lb  	t1, 0(s0)			# le ultimo caractere %
00000377 : 06500213;   % 1224: 		li	tp, 'e'				# TP = 101 = 'e' %
00000378 : 00430c63;   % 1225: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00000379 : 04500213;   % 1226: 		li 	tp, 'E'				# TP = 69 = 'E' %
0000037a : 00430863;   % 1227: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
0000037b : 02e00213;   % 1228: 		li	tp, '.'				# TP = 46 = '.' %
0000037c : 00430463;   % 1229: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
0000037d : 0180006f;   % 1230: 		j 	inicioreadFloat %
0000037e : 00140413;   % 1232: insere0PreadFloat: addi	s0, s0, 1		# desloca o ultimo endereco para o proximo %
0000037f : 00148493;   % 1233: 	   	   addi	s1, s1, 1		# incrementa o num. caracteres %
00000380 : 03000313;   % 1234: 		   li 	t1,'0'			# ascii '0' %
00000381 : 00640023;   % 1235: 		   sb 	t1,0(s0)		# escreve '0' no ultimo %
00000382 : 000400a3;   % 1236: 		   sb 	zero,1(s0)		# \null do final de string %
00000383 : d0007553;   % 1238: inicioreadFloat:  fcvt.s.w 	fa0, zero		# fa0 Resultado inicialmente zero %
00000384 : 00a00293;   % 1239: 		li 	t0, 10			# inteiro 10	 %
00000385 : d002f353;   % 1240: 		fcvt.s.w 	ft6, t0		# ft6 contem sempre o numero cte 10.0000 %
00000386 : 00100293;   % 1241: 		li 	t0, 1			# inteiro 1 %
00000387 : d002f0d3;   % 1242: 		fcvt.s.w 	ft1, t0		# ft1 contem sempre o numero cte 1.0000	 %
00000388 : 00140993;   % 1245: procuraEreadFloat:	addi 	s3, s0, 1			# inicialmente nao tem 'e' ou 'E' na string (fora da string) %
00000389 : 017002b3;   % 1246: 			mv 	t0, s7				# endereco inicial %
0000038a : 02828263;   % 1247: loopEreadFloat: 	beq 	t0, s0, naotemEreadFloat	# sai se nao encontrou 'e' %
0000038b : 00028303;   % 1248: 			lb 	t1, 0(t0)			# le o caractere %
0000038c : 06500213;   % 1249: 			li	tp, 'e'				# TP = 101 = 'e' %
0000038d : 00430a63;   % 1250: 			beq 	t1, tp, ehEreadFloat		# tem 'e' %
0000038e : 04500213;   % 1251: 			li 	tp, 'E'				# TP = 69 = 'E' %
0000038f : 00430663;   % 1252: 			beq	t1, tp, ehEreadFloat		# tem 'E' %
00000390 : 00128293;   % 1253: 			addi 	t0, t0, 1			# incrementa endereco %
00000391 : fe5ff06f;   % 1254: 			j 	loopEreadFloat			# volta ao loop %
00000392 : 005009b3;   % 1255: ehEreadFloat: 		mv 	s3, t0			# endereco do 'e' ou 'E' na string %
00000393 : 01300933;   % 1259: procuraPontoreadFloat:	mv 	s2, s3			# local inicial do ponto na string (='e' se existir) ou fora da string	 %
00000394 : 017002b3;   % 1260: 			mv 	t0, s7			# endereco inicial %
00000395 : 00828e63;   % 1261: loopPontoreadFloat: 	beq 	t0, s0, naotemPontoreadFloat	# sai se nao encontrou '.' %
00000396 : 00028303;   % 1262: 			lb 	t1, 0(t0)			# le o caractere %
00000397 : 02e00213;   % 1263: 			li	tp, '.'				# TP = 46 = '.' %
00000398 : 00430663;   % 1264: 			beq 	t1, tp, ehPontoreadFloat	# tem '.' %
00000399 : 00128293;   % 1265: 			addi 	t0, t0, 1			# incrementa endereco %
0000039a : fedff06f;   % 1266: 			j 	loopPontoreadFloat		# volta ao loop %
0000039b : 00500933;   % 1267: ehPontoreadFloat: 	mv 	s2, t0			# endereco do '.' na string %
0000039c : d0007153;   % 1271: intreadFloat:		fcvt.s.w 	ft2, zero			# zera parte inteira %
0000039d : fff90293;   % 1272: 			addi 	t0, s2, -1			# endereco do caractere antes do ponto %
0000039e : 201081d3;   % 1273: 			fmv.s 	ft3, ft1			# ft3 contem unidade/dezenas/centenas		 %
0000039f : 01700f33;   % 1274: 			mv 	t5, s7			# Primeiro Endereco %
000003a0 : 03e2ca63;   % 1275: loopintreadFloat: 	blt 	t0, t5, fimintreadFloat	# sai se o enderefo for < inicio da string %
000003a1 : 00028303;   % 1276: 			lb 	t1, 0(t0)			# le o caracter %
000003a2 : 03000213;   % 1277: 			li	tp, '0'		# TP = 48 = '0' %
000003a3 : 10434863;   % 1278: 			blt 	t1, tp, erroreadFloat		# nao eh caractere valido para numero %
000003a4 : 03900213;   % 1279: 			li	tp, '9'				# TP = 57 = '9' %
000003a5 : 10624463;   % 1280: 			bgt 	t1, tp, erroreadFloat		# nao eh caractere valido para numero %
000003a6 : fd030313;   % 1281: 			addi 	t1, t1, -48			# converte ascii para decimal %
000003a7 : d0037153;   % 1282: 			fcvt.s.w 	ft2, t1			# digito lido em float %
000003a8 : 10317153;   % 1284: 			fmul.s 	ft2,ft2,ft3			# multiplcica por un/dezena/centena %
000003a9 : 00257553;   % 1285: 			fadd.s 	fa0,fa0,ft2			# soma no resultado %
000003aa : 1061f1d3;   % 1286: 			fmul.s 	ft3,ft3,ft6			# proxima dezena/centena %
000003ab : fff28293;   % 1288: 			addi t0,t0,-1				# endereco anterior %
000003ac : fd1ff06f;   % 1289: 			j loopintreadFloat			# volta ao loop %
000003ad : d0007153;   % 1293: fracreadFloat:		fcvt.s.w 	ft2, zero			# zera parte fracionaria %
000003ae : 00190293;   % 1294: 			addi 	t0, s2, 1			# endereco depois do ponto %
000003af : 1860f1d3;   % 1295: 			fdiv.s 	ft3, ft1, ft6			# ft3 inicial 0.1 %
000003b0 : 0332ea63;   % 1297: loopfracreadFloat: 	bge 	t0, s3, fimfracreadFloat	# endereco eh 'e' 'E' ou >ultimo %
000003b1 : 00028303;   % 1298: 			lb 	t1, 0(t0)			# le o caracter %
000003b2 : 03000213;   % 1299: 			li	tp, '0'				# TP = 48 = '0' %
000003b3 : 0c434863;   % 1300: 			blt 	t1, tp, erroreadFloat		# nao eh valido %
000003b4 : 03900213;   % 1301: 			li	tp, '9'				# TP = 57 = '9' %
000003b5 : 0c624463;   % 1302: 			bgt 	t1, tp, erroreadFloat		# nao eh valido %
000003b6 : fd030313;   % 1303: 			addi 	t1, t1, -48			# converte ascii para decimal %
000003b7 : d0037153;   % 1304: 			fcvt.s.w 	ft2, t1			# digito lido em float		 %
000003b8 : 10317153;   % 1306: 			fmul.s 	ft2, ft2, ft3			# multiplica por ezena/centena %
000003b9 : 00257553;   % 1307: 			fadd.s 	fa0, fa0, ft2			# soma no resultado %
000003ba : 1861f1d3;   % 1308: 			fdiv.s 	ft3, ft3, ft6			# proxima frac un/dezena/centena %
000003bb : 00128293;   % 1310: 			addi 	t0, t0, 1			# proximo endereco %
000003bc : fd1ff06f;   % 1311: 			j 	loopfracreadFloat		# volta ao loop		 %
000003bd : d0007153;   % 1315: potreadFloat:		fcvt.s.w 	ft2, zero			# zera potencia %
000003be : 00198293;   % 1316: 			addi 	t0, s3, 1			# endereco seguinte ao 'e' %
000003bf : 00000a13;   % 1317: 			li 	s4, 0				# sinal do expoente positivo %
000003c0 : 00028303;   % 1318: 			lb 	t1, 0(t0)			# le o caractere seguinte ao 'e' %
000003c1 : 02d00213;   % 1319: 			li	tp, '-'				# TP = 45 = '-' %
000003c2 : 00430863;   % 1320: 			beq	t1, tp, potsinalnegreadFloat	# sinal do expoente esta escrito e eh positivo %
000003c3 : 02b00213;   % 1321: 			li	tp, '+'				# TP = 43 = '+' %
000003c4 : 00430663;   % 1322: 			beq 	t1, tp, potsinalposreadFloat	# sinal do expoente eh negativo %
000003c5 : 00c0006f;   % 1323: 			j 	pulapotsinalreadFloat		# nao esta escrito o sinal do expoente %
000003c6 : 00100a13;   % 1324: potsinalnegreadFloat:	li 	s4, 1				# s4=1 expoente negativo %
000003c7 : 00128293;   % 1325: potsinalposreadFloat:	addi 	t0, t0, 1			# se tiver '-' ou '+' avanca para o proximo endereco %
000003c8 : 00500ab3;   % 1326: pulapotsinalreadFloat:	mv 	s5, t0 			# Neste ponto s5 contem o endereco do primeiro digito da pot e s4 o sinal do expoente		 %
000003c9 : 201081d3;   % 1328: 			fmv.s 	ft3, ft1		# ft3 un/dez/cen = 1 %
000003ca : 00000393;   % 1331: expreadFloat:		li 	t2, 0			# zera expoente %
000003cb : 008002b3;   % 1332: 			mv 	t0, s0		# endereco do ultimo caractere da string %
000003cc : 00a00e13;   % 1333: 			li 	t3, 10			# numero dez %
000003cd : 00100e93;   % 1334: 			li 	t4, 1			# und/dez/cent %
000003ce : 0352c063;   % 1336: loopexpreadFloat:	blt 	t0, s5, fimexpreadFloat	# ainda nao eh o endereco do primeiro digito? %
000003cf : 00028303;   % 1337: 			lb 	t1, 0(t0)			# le o caracter %
000003d0 : fd030313;   % 1338: 			addi 	t1, t1, -48			# converte ascii para decimal %
000003d1 : 03d30333;   % 1339: 			mul 	t1, t1, t4			# mul digito %
000003d2 : 006383b3;   % 1340: 			add 	t2, t2, t1			# soma ao exp %
000003d3 : 03ce8eb3;   % 1341: 			mul 	t4, t4, t3			# proxima casa decimal %
000003d4 : fff28293;   % 1342: 			addi 	t0, t0, -1			# endereco anterior %
000003d5 : fe5ff06f;   % 1343: 			j loopexpreadFloat			# volta ao loop %
000003d6 : 20108153;   % 1347: 			fmv.s 	ft2, ft1			# numero 10^exp  inicial=1 %
000003d7 : 206301d3;   % 1348: 			fmv.s 	ft3, ft6			# se o sinal for + ft3 eh 10 %
000003d8 : 00000213;   % 1349: 			li	tp, 0x00000000			# TP = ZERO %
000003d9 : 004a0463;   % 1350: 			beq 	s4, tp, sinalexpPosreadFloat	# se sinal exp positivo %
000003da : 1860f1d3;   % 1351: 			fdiv.s 	ft3, ft1, ft6			# se o final for - ft3 eh 0.1 %
000003db : 00000293;   % 1352: sinalexpPosreadFloat:	li 	t0, 0				# contador  %
000003dc : 00728863;   % 1353: sinalexpreadFloat: 	beq 	t0, t2, fimsinalexpreadFloat	# se chegou ao fim %
000003dd : 10317153;   % 1354: 			fmul.s 	ft2, ft2, ft3			# multiplica pelo fator 10 ou 0.1 %
000003de : 00128293;   % 1355: 			addi 	t0, t0, 1			# incrementa o contador %
000003df : ff5ff06f;   % 1356: 			j 	sinalexpreadFloat %
000003e0 : 10257553;   % 1359: 		fmul.s 	fa0, fa0, ft2		# multiplicacao final! %
000003e1 : 0fc0f297;   % 1361: 		la 	t0, TempBuffer		# ajuste final do sinal do numero %
000003e2 : 4d028293;   % 1361:  %
000003e3 : 00028303;   % 1362: 		lb 	t1, 0(t0)		# le primeiro caractere %
000003e4 : 02d00213;   % 1363: 		li	tp, '-'			# TP = 45 = '-' %
000003e5 : 00431463;   % 1364: 		bne 	t1, tp, fimreadFloat	# nao eh '-' entao fim %
000003e6 : 20a51553;   % 1365: 		fneg.s 	fa0, fa0		# nega o numero float %
000003e7 : 00012083;   % 1368: fimreadFloat: 	lw 	ra, 0(sp)		# recupera ra %
000003e8 : 00410113;   % 1369: 		addi 	sp, sp, 4		# libera espaco %
000003e9 : 00008067;   % 1370: 		ret						# retorna %
000003ea : 10008237;   % 1462: <70> li tp, 0x10008000			# carrega tp = 0x10008000 %
000003eb : 00020213;   % 1462:  %
000003ec : 00419863;   % 1462: <71> bne gp,tp,timeDE2 %
000003ed : 01e00893;   % 1463: 	li 	a7,30				# Chama o ecall do Rars %
000003ee : 00000073;   % 1464: 	ecall %
000003ef : 0140006f;   % 1465: 	j 	fimTime				# saida %
000003f0 : ff2002b7;   % 1467: timeDE2: 	li 	t0, 0xFF200510			# carrega endereco do TopWatch %
000003f1 : 51028293;   % 1467:  %
000003f2 : 0002a503;   % 1468: 	 	lw 	a0, 0(t0)			# carrega o valor do contador de ms %
000003f3 : 00000593;   % 1469: 	 	li 	a1, 0x0000			# contador eh de 32 bits %
000003f4 : 00008067;   % 1470: fimTime: 	ret					# retorna %
000003f5 : 10008237;   % 1476: <70> li tp, 0x10008000			# carrega tp = 0x10008000 %
000003f6 : 00020213;   % 1476:  %
000003f7 : 00419863;   % 1476: <71> bne gp,tp,sleepDE2 %
000003f8 : 02000893;   % 1477: 	li 	a7, 32				# Chama o ecall do Rars %
000003f9 : 00000073;   % 1478: 	ecall			 %
000003fa : 01c0006f;   % 1479: 	j 	fimSleep			# Saida %
000003fb : ff2002b7;   % 1481: sleepDE2:	li 	t0, 0xFF200510			# endereco StopWatch %
000003fc : 51028293;   % 1481:  %
000003fd : 0002a303;   % 1482: 		lw 	t1, 0(t0)			# carrega o contador de ms %
000003fe : 006503b3;   % 1483: 		add 	t2, a0, t1			# soma com o tempo solicitado pelo usuario %
000003ff : 0002a303;   % 1485: LoopSleep: 	lw 	t1, 0(t0)			# carrega o contador de ms %
00000400 : fe734ee3;   % 1486: 		blt 	t1, t2, LoopSleep		# nao chegou ao fim volta ao loop %
00000401 : 00008067;   % 1488: fimSleep: 	ret				# retorna %
00000402 : 10008237;   % 1494: <70> li tp, 0x10008000			# carrega tp = 0x10008000 %
00000403 : 00020213;   % 1494:  %
00000404 : 00419863;   % 1494: <71> bne gp,tp,randomDE2 %
00000405 : 02900893;   % 1495: 	li 	a7,41			# Chama o ecall do Rars %
00000406 : 00000073;   % 1496: 	ecall	 %
00000407 : 0100006f;   % 1497: 	j 	fimRandom		# saida %
00000408 : ff2002b7;   % 1499: randomDE2: 	li 	t0, 0xFF200514		# carrega endereco do LFSR %
00000409 : 51428293;   % 1499:  %
0000040a : 0002a503;   % 1500: 		lw 	a0, 0(t0)		# le a word em a0 %
0000040b : 00008067;   % 1502: fimRandom:	ret				# retorna %
0000040c : ff000337;   % 1511: clsCLS:	li      t1, 0xFF000000           # Memoria VGA %
0000040d : 00030313;   % 1511:  %
0000040e : ff0133b7;   % 1512:    	li      t2, 0xFF012C00 %
0000040f : c0038393;   % 1512:  %
00000410 : 0ff57513;   % 1513:     	andi    a0, a0, 0x00FF %
00000411 : 010102b7;   % 1514:     	li 	t0, 0x01010101 %
00000412 : 10128293;   % 1514:  %
00000413 : 02a28533;   % 1515:     	mul	a0, t0, a0 %
00000414 : 00730863;   % 1517: forCLS:	beq     t1, t2, fimCLS %
00000415 : 00a32023;   % 1518: 	sw      a0, 0(t1) %
00000416 : 00430313;   % 1519:     	addi    t1, t1, 4 %
00000417 : ff5ff06f;   % 1520:     	j       forCLS %
00000418 : 00008067;   % 1522: fimCLS:	ret %
END;
